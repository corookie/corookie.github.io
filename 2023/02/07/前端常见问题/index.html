<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>前端常见问题 | Corookie's Blog</title><meta name="author" content="Corookie"><meta name="copyright" content="Corookie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="面试题面向对象：程序中所有的操作都需要通过对象完成 操作浏览器：操作window对象 操作网页要用document对象 操作控制台用console对象 一切操作都通过对象进行完成，在程序中所有的对象都被分成两部分 数据和功能。 HTML1、html语义化 html有很多语义化的标签，像nav 、 footer 、header 、main 、artical等 代码结构清晰，并且方便其他设备解析，并且">
<meta property="og:type" content="article">
<meta property="og:title" content="前端常见问题">
<meta property="og:url" content="https://corookie.github.io/2023/02/07/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="Corookie&#39;s Blog">
<meta property="og:description" content="面试题面向对象：程序中所有的操作都需要通过对象完成 操作浏览器：操作window对象 操作网页要用document对象 操作控制台用console对象 一切操作都通过对象进行完成，在程序中所有的对象都被分成两部分 数据和功能。 HTML1、html语义化 html有很多语义化的标签，像nav 、 footer 、header 、main 、artical等 代码结构清晰，并且方便其他设备解析，并且">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2023-02-07T07:45:23.000Z">
<meta property="article:modified_time" content="2023-02-17T08:18:36.119Z">
<meta property="article:author" content="Corookie">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/icon.jpg"><link rel="canonical" href="https://corookie.github.io/2023/02/07/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端常见问题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-17 16:18:36'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/icon.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Corookie's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端常见问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-07T07:45:23.000Z" title="发表于 2023-02-07 15:45:23">2023-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-17T08:18:36.119Z" title="更新于 2023-02-17 16:18:36">2023-02-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端常见问题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><p>面向对象：程序中所有的操作都需要通过对象完成</p>
<p>操作浏览器：操作window对象</p>
<p>操作网页要用document对象</p>
<p>操作控制台用console对象</p>
<p>一切操作都通过对象进行完成，在程序中所有的对象都被分成两部分 数据和功能。</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="1、html语义化"><a href="#1、html语义化" class="headerlink" title="1、html语义化"></a>1、html语义化</h3><p> html有很多语义化的标签，像nav 、 footer 、header 、main 、artical等</p>
<p>代码结构清晰，并且方便其他设备解析，并且有利于搜索引擎结果(SEO)优化。</p>
<h3 id="2、script中defer和async的区别"><a href="#2、script中defer和async的区别" class="headerlink" title="2、script中defer和async的区别"></a>2、script中defer和async的区别</h3><p>下载的时候堵不堵塞进程？ 什么时候执行脚本？</p>
<p>不添加defer和async，script标签中引入脚本会阻止html文件的解析，需得等待下载并执行完毕 html页面才会继续解析。</p>
<p><strong>async</strong> 解析html的时候会异步下载脚本  下载成功后立即执行，可能会阻塞html文件的执行</p>
<p><strong>defer</strong>  异步下载脚本，等到html加载完毕在执行。</p>
<h3 id="3、DOCTYPE"><a href="#3、DOCTYPE" class="headerlink" title="3、DOCTYPE"></a>3、DOCTYPE</h3><p><code>&lt;!DOCTYE&gt;</code> 声明一般位于文档的第一行，它的作用主要是告诉浏览器以什么样的模式来解析文档。一般指定了之后会以“标准模式”进行文档解析，否则就以“兼容模式”进行解析。</p>
<ul>
<li>在<code>标准模式</code>下，浏览器的解析规则都是按照最新的标准进行解析的。</li>
<li>而在<code>兼容模式</code>下，浏览器会以向后兼容的方式来模拟老式浏览器的行为，以保证一些老的网站能正常访问。</li>
</ul>
<h3 id="4、SGML、HTML、XML-和-XHTML的区别"><a href="#4、SGML、HTML、XML-和-XHTML的区别" class="headerlink" title="4、SGML、HTML、XML 和 XHTML的区别"></a>4、SGML、HTML、XML 和 XHTML的区别</h3><p><code>SGML</code> 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</p>
<p><code>HTML</code> 是超文本标记语言，主要是用于规定怎样显示网页。</p>
<p><code>XML</code> 是可扩展标记语言，是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。</p>
<p><code>XHTML</code> 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</p>
<h3 id="5、HTML5"><a href="#5、HTML5" class="headerlink" title="5、HTML5"></a>5、HTML5</h3><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像、位置、存储、多任务等功能的增加。</p>
<p>新增的：</p>
<ul>
<li>绘图 <code>canvas</code></li>
<li>用于媒介回放的 <code>video</code> 和 <code>audio</code> 元素</li>
<li>本地离线存储 <code>localStorage</code> 、<code>sessionStorage</code></li>
<li>语义化更好的内容元素，如：<code>header</code>、<code>article</code>、<code>nav</code>、<code>section</code>、<code>footer</code>等</li>
<li>表单控件 <code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code> 等</li>
<li>新的技术 <code>webworker</code>、<code>websocket</code></li>
<li>新的文档属性 <code>document.visibilityState</code></li>
</ul>
<p>移除的：</p>
<ul>
<li>纯表现的元素：<code>basefont</code>、<code>big</code>、<code>center</code>、<code>s</code>、<code>tt</code>、<code>u</code></li>
<li>对可用性产生负面影响的元素：<code>frame</code>、<code>frameset</code>、<code>noframes</code></li>
</ul>
<h3 id="6、浏览器内核的理解"><a href="#6、浏览器内核的理解" class="headerlink" title="6、浏览器内核的理解"></a>6、浏览器内核的理解</h3><p>主要分为两部分：渲染引擎和JS引擎。</p>
<ul>
<li><code>渲染引擎</code>：其职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 HTML、 XML 文档及图片，它也可以借助一些浏览器扩展插件显示其他类型数据，如：使用PDF阅读器插件可以显示 PDF 格式。</li>
<li><code>JS引擎</code>：解析和执行 JavaScript 来实现网页的动态效果。</li>
</ul>
<p>最开始渲染引擎和JS引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于只指渲染引擎了。</p>
<h3 id="7、什么是文档的预解析？"><a href="#7、什么是文档的预解析？" class="headerlink" title="7、什么是文档的预解析？"></a>7、什么是文档的预解析？</h3><p>​    当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载，从而使整体速度更快。</p>
<p>需要注意的是，预解析并不改变DOM树，它将这个工作交给主解析过程，自己只解析外部资源的引用，比如：外部脚本、样式及图片。</p>
<h3 id="8、sessionStorage，localStorage-和-cookie-的区别"><a href="#8、sessionStorage，localStorage-和-cookie-的区别" class="headerlink" title="8、sessionStorage，localStorage 和 cookie 的区别"></a>8、sessionStorage，localStorage 和 cookie 的区别</h3><p>cookie 是储存在浏览器缓存里的 最大不超过4kb</p>
<p>localStorage 是本地缓存文件 永久有效</p>
<p>sessionStorage类似内存 浏览器页面关闭就消失</p>
<ol>
<li>共同点：都是保存在浏览器端，且同源的</li>
<li>区别:</li>
</ol>
<ul>
<li>cookie 始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器之间来回传递；而 sessionStorage 和 localStorage 不会自动把数据发送到服务器，仅在本地保存。cookie 还有路径（path）的概念，可以限制 cookie 只属于某个路径下。</li>
<li>存储大小限制不同。cookie 不能超过 4K，因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据，如：会话标识。sessionStorage 和 localStorage 虽然也有存储大小限制，但比 cookie 大得多，可以达到 5M 或更大。</li>
<li>数据有效期不同。sessionStorage 仅在当前浏览器窗口关闭之前有效；localStorage 始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie 只在设置的 cookie 过期时间之前有效。</li>
<li>作用域不同。sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 和 cookie 在所有同源窗口中都是共享的。</li>
</ul>
<h3 id="9、iframe-有哪些优缺点？"><a href="#9、iframe-有哪些优缺点？" class="headerlink" title="9、iframe 有哪些优缺点？"></a>9、iframe 有哪些优缺点？</h3><p><strong>HTML 内联框架元素 (<code>&lt;iframe&gt;</code>)</strong> 表示嵌套的<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Glossary/Browsing_context">browsing context</a>。它能够将另一个 HTML 页面嵌入到当前页面中。</p>
<p>优点：</p>
<ol>
<li>iframe 能原封不动的把嵌入的网页展现出来。</li>
<li>如果有多个网页引用 iframe，只需修改 iframe 的内容，就可以实现调用每一个页面的更改，方便快捷。</li>
</ol>
<p>缺点：</p>
<ol>
<li>iframe 会阻塞主页面的 onload 事件。</li>
<li>iframe 和主页面共享链接池，而浏览器对相同域的链接有限制，所以会影响页面的并行加载。</li>
<li>不利于 SEO，代码复杂，无法一下被搜索引擎索引到。</li>
<li>iframe 框架页面会增加服务器的 http 请求，对于大型网站不可取。</li>
<li>很多移动设备无法完全显示框架，设备兼容性差。</li>
</ol>
<p>注意：通过动态给 iframe 添加 src 属性值，可解决前两个问题。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="1、说一说CSS的盒子模型"><a href="#1、说一说CSS的盒子模型" class="headerlink" title="1、说一说CSS的盒子模型"></a>1、说一说CSS的盒子模型</h3><p>​    把html中的元素看作一个矩形盒子容器，盒子由内容(content)、padding、margin和border组成，而一个网页就是由一定数量的盒子构建而成。其中width和height为content的宽度和高度，</p>
<p>css的盒子模型标准盒模型和怪异盒模型(ie)</p>
<ul>
<li><p>标准盒子模型</p>
<p>content就是content，width和height就是content的尺寸</p>
</li>
<li><p>IE盒子模型</p>
<p>content包括padding + border，width是这是三部分的宽度</p>
</li>
</ul>
<h3 id="2、css选择器优先级"><a href="#2、css选择器优先级" class="headerlink" title="2、css选择器优先级"></a>2、css选择器优先级</h3><p>！important &gt; 行内(1000)&gt; id(100) &gt; class类(10) &gt; 标签选择器（1） &gt;子选择器(ul&gt;li  0) &gt; 后代选择器（ul li a）&gt; 伪类选择</p>
<h3 id="3、元素隐藏方法有哪些"><a href="#3、元素隐藏方法有哪些" class="headerlink" title="3、元素隐藏方法有哪些"></a>3、元素隐藏方法有哪些</h3><p>display：none  真正的隐藏</p>
<p>opacity : 0</p>
<p>visibility : hidden  后代不受影响</p>
<h3 id="4、px和rem的区别"><a href="#4、px和rem的区别" class="headerlink" title="4、px和rem的区别"></a>4、px和rem的区别</h3><p>×</p>
<p>px相对显示器分辨率而设置的 算是一个标准单位 有固定的长度</p>
<p>em相对父元素设置的 没有固定的标准</p>
<p>rem相对html根元素设置的 正常浏览器为16px</p>
<ul>
<li>布局方面，flex布局用的比较多 给父元素设置flex 接着可以按主轴(justify-content)方向和交叉轴方向(align-items)随意布局</li>
</ul>
<h3 id="5、重绘重排有什么区别"><a href="#5、重绘重排有什么区别" class="headerlink" title="5、重绘重排有什么区别"></a>5、重绘重排有什么区别</h3><p>×</p>
<p>页面生成过程</p>
<p>1.HTML 被 HTML 解析器解析成 DOM 树；</p>
<p>2.CSS  被 CSS 解析器解析成 CSSOM 树；</p>
<p>3.结合 DOM 树和 CSSOM 树，生成一棵渲染树(Render Tree)，这一过程称为 Attachment；</p>
<p>4.生成布局(flow)，浏览器在屏幕上“画”出渲染树中的所有节点；</p>
<p>5.将布局绘制(paint)在屏幕上，显示出整个页面。</p>
<p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染</p>
<p>​    在页面的生命周期中，**网页生成的时候，至少会渲染一次。在用户访问的过程中，还会不断触发重排(reflow)和重绘(repaint)**，不管页面发生了重绘还是重排，都会影响性能，最可怕的是重排，会使我们付出高额的性能代价，所以我们应尽量避免。</p>
<ul>
<li><p>重绘：某些元素的外观被改变，例如：元素的填充颜色</p>
</li>
<li><p>重排：重新生成布局，重新排列元素。</p>
<p>​    当DOM的变化影响了元素的几何信息(元素的的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。重排也叫回流，简单的说就是重新生成布局，重新排列元素。</p>
<p>因此需要尽可能减少重排，有几点需要注意：</p>
<ol>
<li>使用 transform 代替 top</li>
<li>不要把节点的属性值放在一个循环里，当成循环里的变量</li>
<li>不要使用 table 布局，可能很小的一个改动会造成整个 table 的重新布局</li>
<li>把 DOM 离线后修改。如：使用 documentFragment 对象在内存里操作 DOM</li>
<li>不要一条一条的修改样式，可以预先定义好 class，然后修改 DOM 的 className</li>
<li>使用 absolute 或 fixed 使元素脱离文档流</li>
</ol>
</li>
</ul>
<h3 id="6、让一个元素水平垂直居中的方法有哪些"><a href="#6、让一个元素水平垂直居中的方法有哪些" class="headerlink" title="6、让一个元素水平垂直居中的方法有哪些"></a>6、让一个元素水平垂直居中的方法有哪些</h3><ol>
<li>设置flex，然后根据主轴交叉轴进行编辑（最常用）</li>
<li>子绝父相 使用margin进行编辑 记得设置top left bottom right 为0</li>
<li>子绝父相 通过绝对定位 top left 但要设置margin</li>
<li>display： table-cell 然后设置text-align center 和 vertical-align使其水平垂直居中</li>
</ol>
<h3 id="7、CSS属性那些可以继承那些不能继承"><a href="#7、CSS属性那些可以继承那些不能继承" class="headerlink" title="7、CSS属性那些可以继承那些不能继承"></a>7、CSS属性那些可以继承那些不能继承</h3><p>padding margin background-Color  border color text-align </p>
<p>能继承的：font相关 color 相关 visibility</p>
<p>不能继承的： display  background相关  盒子相关  定位属性</p>
<h3 id="8、有没有用过预处理器"><a href="#8、有没有用过预处理器" class="headerlink" title="8、有没有用过预处理器"></a>8、有没有用过预处理器</h3><p>×</p>
<p>css预处理器  less</p>
<p>结构更为清晰  写起来更简便、舒适</p>
<h2 id="JAVASCRIPT"><a href="#JAVASCRIPT" class="headerlink" title="JAVASCRIPT"></a>JAVASCRIPT</h2><h3 id="1、JS由那三部分组成"><a href="#1、JS由那三部分组成" class="headerlink" title="1、JS由那三部分组成"></a>1、JS由那三部分组成</h3><p>ECMAScript  DOM   BOM</p>
<h3 id="2、JS有那些内置对象"><a href="#2、JS有那些内置对象" class="headerlink" title="2、JS有那些内置对象"></a>2、JS有那些内置对象</h3><p>Array Date String  Math</p>
<h3 id="3、操作数组的方法有那些"><a href="#3、操作数组的方法有那些" class="headerlink" title="3、操作数组的方法有那些"></a>3、操作数组的方法有那些</h3><p>join()  concat  splice(插入 删除  替换)</p>
<p>push pop shift unshift  index indexOf  </p>
<p>filter map forEach reverse sort（a&lt;b 降序 a&gt;b升序） slice</p>
<h3 id="4、-JS对数据的检测方法"><a href="#4、-JS对数据的检测方法" class="headerlink" title="4、 JS对数据的检测方法"></a>4、 JS对数据的检测方法</h3><p>instance of  检测原型的   适合用于array等复杂数据类型的检测  无法检测原始值</p>
<p>constructor 用于获取实例或类的构造函数 [].constructor == array    //true</p>
<p>typeof 适合原始数据类型检测 除了null之外的原始值都很好检测，对object类型难以检测</p>
<h3 id="5、说一下闭包，闭包有什么特点。"><a href="#5、说一下闭包，闭包有什么特点。" class="headerlink" title="5、说一下闭包，闭包有什么特点。"></a>5、说一下闭包，闭包有什么特点。</h3><ul>
<li><p>能够读取其他函数内部变量的函数。</p>
</li>
<li><p>或简单理解为定义在一个函数内部的函数，内部函数持有外部函数内变量的引用。</p>
<p>​    在函数上下文中，闭包内能访问所有的上文变量和对象，而外部无法访问闭包内部的变量，闭包能让让这些变量的值始终保持在内存中。不会在f1调用后被自动清除。利于代码封装。</p>
<p>​    <strong>缺点</strong>：闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>​    闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p>
</li>
</ul>
<h3 id="7、事件委托是什么"><a href="#7、事件委托是什么" class="headerlink" title="7、事件委托是什么"></a>7、事件委托是什么</h3><p>×</p>
<p>​    事件委托也称之为事件代理（Event Delegation）。是JavaScript中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是当事件被触发会在子元素和父元素之间传播分为：捕获、目标、冒泡阶段。</p>
<p>优点就是减少内存，并且添加新的子对象的时候无需再单独绑定注册事件。</p>
<h3 id="8、基本数据类型和引用数据类型的区别"><a href="#8、基本数据类型和引用数据类型的区别" class="headerlink" title="8、基本数据类型和引用数据类型的区别"></a>8、基本数据类型和引用数据类型的区别</h3><p>JS分两种数据类型：</p>
<p>　　　　基本数据类型：Number、String、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Boolean&spm=1001.2101.3001.7020">Boolean</a>、Null、 Undefined、Symbol（ES6），这些类型可以直接操作保存在变量中的实际值。</p>
<p>　　　　引用数据类型：Object（在JS中除了基本数据类型以外的都是对象，数据是对象，函数是对象，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&spm=1001.2101.3001.7020">正则表达式</a>是对象）</p>
<p>​    栈(stack)和堆（heap）</p>
<p>　　stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小也不一定会自动释放</p>
<p>​    基本数据类型是放在栈中的一段值，对基本数据类型做改变会直接改变位于栈上面的值；引用数据类型是放在堆上的数据段，栈中只是存放着指向堆中的指针。</p>
<p>​    深拷贝和浅拷贝</p>
<p><img src="/2023/02/07/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%A0%88%E5%92%8C%E5%A0%86.jpg"></p>
<h3 id="9、说一下原型链"><a href="#9、说一下原型链" class="headerlink" title="9、说一下原型链"></a>9、说一下原型链</h3><p>​    JavaScript 对象是动态的属性“包”（指其自己的属性）。JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。末尾大部分都是object</p>
<p>类似于家族  下代可使用上代的方法，</p>
<h3 id="10、new操作符具体做了什么"><a href="#10、new操作符具体做了什么" class="headerlink" title="10、new操作符具体做了什么"></a>10、new操作符具体做了什么</h3><p>使用构造函数构造了一个实例</p>
<p>​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                1、创建了一个空的js对象（即{}）</p>
<p>2、将空对象的原型prototype指向构造函数的原型</p>
<p>3、将空对象作为构造函数的上下文（改变this指向）</p>
<p>4、对构造函数有返回值的判断</p>
<h3 id="11、类型判断"><a href="#11、类型判断" class="headerlink" title="11、类型判断"></a>11、类型判断</h3><p>typeof  适合原始值的判断 number string boolean symbol null undefined</p>
<p>其中null  和 object 结果都是object，因此还需要进一步的分辨</p>
<p>instanceof 适合复杂类型的判断  null  object array</p>
<p>object.constructor 判断构造函数</p>
<h3 id="12、bind-call-apply区别"><a href="#12、bind-call-apply区别" class="headerlink" title="12、bind, call, apply区别"></a>12、bind, call, apply区别</h3><p>这三个方法都是用于改变函数体内this的指向的.</p>
<p>bind与apply和call的最大的区别是：bind不会立即调用，而是返回一个新函数，称为绑定函数，第一个参数是原</p>
<p>函数内部this的指向，之后的参数是原函数的参数。而apply和call会直接调用并返回结果。还有就是bind是硬绑</p>
<p>定，返回的绑定函数不能再通过bind、apply、call修改，call与apply的绑定只适用当前调用，调用完就没了，下</p>
<p>次要用还得再次绑。</p>
<p>apply和call的唯一区别在于，要传递给调用函数的参数，call是以散列的形式，一个个列出来传过去的，apply是</p>
<p>以数组的形式传递进去的。所以call的性能要好一些，apply还要多一步解析数组的工作。</p>
<p>var a = func.bind(thisArg[, arg1[, arg2[, …]]])</p>
<p>a()</p>
<p>fun.call(thisArg, arg1, arg2, …)</p>
<p>fun.apply(thisArg, [argsArray])</p>
<p>实现：</p>
<p>call</p>
<p>将function作为obj的属性</p>
<p>让obj调用这个函数</p>
<p>调用完将这个属性删除</p>
<p>除了这些, 我们还应该考虑到像函数的返回值, 参数列表, thisArg的类型等问题</p>
<p>Function.prototype.myCall = function(context) {</p>
<p>​    let context = context || window</p>
<p>​    // 1.将函数设为对象的属性(this指向当前函数, context是传入的对象)</p>
<p>​    context.fn = this;</p>
<pre><code>let args = [...arguments].slice(1)

// 2.执行该函数
let result = context.fn(...args)

// 3.执行完后删除函数
delete context.fn
return result
</code></pre>
<p>}<br>apply</p>
<p>与call的区别就是arguments</p>
<p>Function.prototype.myApply = function(context) {</p>
<p>​    let context = context || window</p>
<p>​    let result</p>
<p>​    context.fn = this</p>
<pre><code>if (arguments[1]) &#123;
    result = context.fn(...arguments[1])
&#125; else &#123;
    result = context.fn()
&#125;
delete context.fn
return result
</code></pre>
<p>}<br>bind<br>Function.prototype.myBind = function(context) {<br>    let _this = this<br>    let args = […arguments].slice(1)<br>    // 返回一个函数<br>    return function F() {<br>        // 因为返回了一个函数，我们可以 new F()，所以需要判断<br>        if (this instanceof F) {<br>            return new _this(…args, …arguments)<br>        }<br>        return _this.apply(context, […args, …arguments])<br>    }<br>}</p>
<h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><h4 id="1、mvvm模型"><a href="#1、mvvm模型" class="headerlink" title="1、mvvm模型"></a>1、mvvm模型</h4><p>m：model（模型，储存数据的地方）  v:view(展示数据的地方) </p>
<p>vm ： 构建二者的桥梁，实现数据的双向绑定</p>
<h4 id="2、vue数据双向绑定原理"><a href="#2、vue数据双向绑定原理" class="headerlink" title="2、vue数据双向绑定原理"></a>2、vue数据双向绑定原理</h4><p>​    vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过<strong>Object.defineProperty()**来劫持各个属性的**setter**，</strong>getter**，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>通过object.definiteProperty ，给各个属性设置getter 和 setter，</p>
<p>​    <strong>具体步骤：</strong> <strong>第一步：</strong> 需要 <strong>observe</strong> 的数据对象进行递归遍历，包括子属性对象的属性，都加上 <strong>setter</strong> 和<strong>getter</strong> 这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</p>
<p><strong>第二步：</strong>  <strong>compile 解析模板指令</strong>，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</p>
<p><strong>第三步：</strong>  <strong>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁</strong>，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个 <strong>update()</strong> 方法 3、待属性变动 <strong>dep.notice()</strong> 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。</p>
<p>第四步：MVVM 作为数据绑定的入口，整合 <strong>Observer、Compile 和 Watcher</strong> 三者，通过 Observer 来监听自己的 model 数据变化， 通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新； 视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</p>
<p>​    vue的双向数据绑定原理是借用了obeject.defineProperty getter 和 setter。vue是mvvm的架构，其中v是view，负责展示数据，m是model 负责储存数据，vm则是中转站，负责处理数据。</p>
<p>​    当model的数据发生变化的时候，model中有一个observe，会给每一个数据属性加上getter 和 setter ，当数据发生变化时，observe</p>
<p>会通过getter 监听到数据变化，然后通知vm中的watcher，watcher触发update更新，并触发view中的compile中绑定的回调，进而收到</p>
<p>数据更新视图。</p>
<p>​    在vue3中使用proxy对数据进行双向绑定。proxy和defineproperty区别：</p>
<p>数组：vue中为了实现数组的双向绑定，对数组方法进行了改写，</p>
<p>对象</p>
<h4 id="3、vue生命周期钩子"><a href="#3、vue生命周期钩子" class="headerlink" title="3、vue生命周期钩子"></a>3、vue生命周期钩子</h4><p><img src="/2023/02/07/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
<p>开始初始化生命周期、但数据代理还未开始</p>
<p><strong>before created</strong>  无法通过vm访问到数据和methods</p>
<p>初始化：数据代理和检测</p>
<p><strong>created</strong>   可以通过vm访问数据和methods</p>
<p>vue开始解析模板 生成虚拟dom</p>
<p><strong>before mounted</strong> 生成未经vue编译的虚拟dom</p>
<p>转换为真实dom  开始渲染</p>
<p><strong>mounted</strong>  经过vue编译的dom，页面挂载完毕</p>
<p><strong>beforeupdate</strong> 数据是新的但页面是旧的</p>
<p>对比两个虚拟dom，通过双向数据绑定原理去更新页面</p>
<p><strong>updated</strong> 数据更新完毕</p>
<p><strong>beforeunmounted</strong>  关闭定时器  解绑自定义事件 等 数据和方法是可用的</p>
<p><strong>unmounted</strong></p>
<h4 id="4、v-if-和-v-show"><a href="#4、v-if-和-v-show" class="headerlink" title="4、v-if 和 v-show"></a>4、v-if 和 v-show</h4><p>v-if操作的 是真实的dom 存在 或者不存在 因此v-if的变化会引起重排。</p>
<p>v-show 只是简单的操作display ： none or block</p>
<p>尽可能多的使用v-show  少用v-if</p>
<h4 id="5、async-（a-sin-k）await-是什么？它有哪些作用？"><a href="#5、async-（a-sin-k）await-是什么？它有哪些作用？" class="headerlink" title="5、async （a sin k）await 是什么？它有哪些作用？"></a>5、async （a sin k）await 是什么？它有哪些作用？</h4><p>async 表明该函数是异步的  有效防止了堵塞</p>
<p>​    <strong>async await</strong> 是<strong>es7</strong>里面的新语法、它的作用就是 async 用于申明一个 function 是异步的，而 await 用 于等待一个异步方法执行完成。它可以很好的替代<strong>promise 中的 then</strong></p>
<p>​    async 函数返回一个 Promise 对象，可以使用 <strong>then</strong> 方法添加回调函数。当函数执行的时候，一旦遇 到 <code>await </code>就会先返回， 等到异步操作完成，再接着执行函数体内后面的语句。</p>
<h4 id="6、-谈谈闭包"><a href="#6、-谈谈闭包" class="headerlink" title="6、 谈谈闭包"></a>6、 谈谈闭包</h4><p>​    闭包简单来说就是函数包函数，在作用域的影响下，内部函数能够读取返回外部函数的属性，而外部函数只能读取内部函数属性值，而无法修改闭包内部属性值。</p>
<p>​    函数内部返回一个函数</p>
<p>优点</p>
<ul>
<li>可以读取函数内部的变量</li>
<li>避免了全局污染</li>
</ul>
<p>缺点</p>
<ul>
<li><p>变量不会被收回，消耗的内存</p>
</li>
<li><p>使用不当会造成内存泄漏等问题</p>
</li>
</ul>
<h4 id="7、ES6新特性"><a href="#7、ES6新特性" class="headerlink" title="7、ES6新特性"></a>7、ES6新特性</h4><p>es6是2015年退出的一个新的版本 相比与es5做了较大的变动。</p>
<p>新增 let const 变量声明语法，具有块级作用域，不存在变量声明。新增箭头函数，方便函数的声明，并且箭头函数没有this ，她的this取决于外部环境。</p>
<p>新增promise ，解决了回调地狱的问题，新增模块化 使用export 、import来导入和加载 ；</p>
<p>新增了<strong>结构赋值</strong>， ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 （Destructuring）。</p>
<p>新增了<strong>class 类</strong>的概念，它类似于对象。</p>
<h4 id="8、key和index"><a href="#8、key和index" class="headerlink" title="8、key和index"></a>8、key和index</h4><p>​    循环的时候，最好不要用index 作为key，因为index会变，删除中间的数据，下面数据的index发生变动，导致key发生变动，从而会导致数据重新渲染。影响性能。</p>
<h4 id="9、组件中的-data-为什么要定义成一个函数而不是一个对象？"><a href="#9、组件中的-data-为什么要定义成一个函数而不是一个对象？" class="headerlink" title="9、组件中的 data 为什么要定义成一个函数而不是一个对象？"></a>9、组件中的 data 为什么要定义成一个函数而不是一个对象？</h4><p>对象是引用类型的值，组件是vue的实例，而所有的组件共享data，当data设置为引用的值，一个发生改变 则会影响到其他，这并不利于实际开发。</p>
<h4 id="10、vue-中-computed-和-watch-的区别是什么？"><a href="#10、vue-中-computed-和-watch-的区别是什么？" class="headerlink" title="10、vue 中 computed 和 watch 的区别是什么？"></a>10、vue 中 computed 和 watch 的区别是什么？</h4><p>computed 能实现的 watch都能实现。</p>
<p><code>computed</code>计算属性就是为了简化 template 里面模版字符串的计算复杂度、防止模版太过冗余。</p>
<p>它具有 缓存特性 computed 用来监控自己定义的变量，该变量不在 data 里面声明，直接在 computed 里面定义，然后就 可以在页面上进行双向数据绑定展示出结果或者用作其他处理；</p>
<p><code>watch</code>主要用于<strong>监控 vue 实例的变化</strong>，它监控的变量当然必须在 data 里面声明才可以，它可以监控一个 变量，也可以是一个对象，一般用于监控路由、input 输入框的值特殊处理等等，它比较适合的场景是 一个数据影响多个数据，它不具有缓存性</p>
<ul>
<li>watch：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。</li>
<li>computed：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才 会重新计算。</li>
</ul>
<p>除此之外，有点很重要的区别是：<strong>计算属性不能执行异步任务，计算属性必须同步执行</strong>。也就是说计算 属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。<strong>watch 也可以检测 computed 属性。</strong></p>
<h4 id="11、"><a href="#11、" class="headerlink" title="11、"></a>11、</h4><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h4 id="1、输入url到页面渲染发生了什么"><a href="#1、输入url到页面渲染发生了什么" class="headerlink" title="1、输入url到页面渲染发生了什么"></a>1、输入url到页面渲染发生了什么</h4><p><code>url解析</code>：首先会判断输入的是一个合法 url还是关键词，并根据输入的内容进行相应的操作。</p>
<p><code>查找缓存</code>：浏览器会判断所请求的资源是否在浏览器缓存中，以及是否失效。如果没有失效就直接使用；如果没有缓存或失效了，就继续下一步。</p>
<p><code>DNS解析</code>：此时需要获取url中域名对应的IP地址。浏览器会依次查看<code>浏览器缓存</code>、<code>操作系统缓存</code>中是否有ip地址，如果缓存中没有就会向<code>本地域名服务器</code>发起请求，获取ip地址。<code>本地域名服务器</code>也会先检查缓存，有则直接返回；如果也没有，则采用<code>迭代查询</code>方式，向上级域名服务器查询。先向<code>根域名服务器</code>发起请求，获取<code>顶级域名服务器</code>的地址；再向<code>顶级域名服务器</code>发起请求以获取<code>权限域名服务器</code>地址；然后向<code>权限域名服务器</code>发起请求并得到url中域名对应的IP地址。</p>
<p>（将域名转化为ip地址的一个过程）</p>
<p><code>建立TCP连接</code>：根据ip地址，<code>三次握手</code>与服务器建立TCP连接。</p>
<p>tcp是一个链接协议，TCP( Transmission control protocol )即传输控制协议，是一种面向连接（数据传输之前客户端和服务器必须建立链接）、可靠(数据传输之前必须经过校验) 的数据传输协议，它是为了在不可靠的互联网上提供可靠的端到端字节流而专门设计的一个传输协议。</p>
<p>在传输前必须经历过三次握手，三次握手是为了检验双方的发送和接受能力是否正常。</p>
<ul>
<li>第一次握手： 客户端向服务器端发送报文（syn = 1 ， seq = x） 客户端进入SYN-SENT<br>证明客户端的发送能力正常</li>
<li>第二次握手：服务器端接收到报文并向客户端发送报文(syn = 1, ACK = 1 , seq = y,ack = x + 1)) SYN-RCVD<br>证明服务器端的接收能力、发送能力正常</li>
<li>第三次握手：客户端向服务器发送报文(ACK = 1,seq = x+1 ,ack = y+1) ESTABLISHED<br>证明客户端的接收能力正常</li>
</ul>
<p><code>发起请求</code>：浏览器向服务器发起HTTP请求。</p>
<p><code>响应请求</code>：服务器响应HTTP请求，将相应的HTML文件返回给浏览器。</p>
<p><code>关闭TCP连接</code>：<code>四次挥手</code>关闭TCP连接。</p>
<p>第一次挥手 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态</p>
<p>第二次挥手 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态</p>
<p>第三次挥手 客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<p>第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成</p>
<p>为什么客户端要等待2MSL？<br>主要原因是为了保证客户端发送那个的第一个ACK报文能到到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。</p>
<ul>
<li><code>构建DOM树</code>：词法分析然后解析成DOM树，DOM树是由DOM元素及属性节点组成，树的根是document对象。</li>
<li><code>构建CSS规则树</code>：生成CSS 规则树。</li>
<li><code>构建渲染树</code>：将DOM树和CSS规则树结合，构建出渲染树。</li>
<li><code>布局</code>：计算每个节点的位置。</li>
<li><code>绘制</code>：使用浏览器的UI接口进行绘制。</li>
</ul>
<h4 id="2、http请求"><a href="#2、http请求" class="headerlink" title="2、http请求"></a>2、http请求</h4><p><code>HTTP (HyperText Transfer Protocol)</code>，即超文本传输协议，是一种实现网络通信的规范。它定义了客户端和服务器之间交换报文的格式和方式，默认使用的是<code>80端口</code>，其底层使用<code>TCP</code>作为传输层协议，保证了数据传输的可靠性。</p>
<p>特点：</p>
<ul>
<li>简单快速：客户端向服务器请求服务时，只需传送请求方法和路径。由于<code>HTTP</code>协议简单，使得<code>HTTP</code>服务器的规模小，因而通信速度很快。</li>
<li>灵活：<code>HTTP</code>允许传输任意类型的数据对象。</li>
<li>无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。</li>
<li>无状态：<code>HTTP</code>协议无法根据之前的状态进行本次的请求处理。</li>
<li>明文：<code>HTTP</code>是以明文的形式传递内容。</li>
</ul>
<h4 id="3、https和http的区别"><a href="#3、https和http的区别" class="headerlink" title="3、https和http的区别"></a>3、https和http的区别</h4><p>更安全，</p>
<p><code>HTTPS</code>是<code>HTTP</code>协议的安全版本。<code>HTTPS</code>的出现主要是为了解决<code>HTTP</code>明文传输内容导致其不安全的特性。为保证数据加密传输，让<code>HTTP</code>运行安全的<code>SSL/TLS</code>协议上，即 <code>HTTPS = HTTP + SSL/TLS</code>。通过<code>SSL</code>证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p>
<p>二者的区别：</p>
<ul>
<li>安全性：<code>HTTP</code>协议的数据传输是明文的，是不安全的；<code>HTTPS</code> 使用了<code>SSL/TLS</code>协议进行加密处理，相对更加安全。</li>
<li>连接方式：二者使用的连接方式不同，<code>HTTP</code>是三次握手，<code>HTTPS</code>是三次握手+数字证书。</li>
<li>默认端口：<code>HTTP</code>的默认端口是<code>80</code>；<code>HTTPS</code>的默认端口是<code>443</code>。</li>
<li>响应速度：由于<code>HTTPS</code>需要进行加解密过程，因此速度不如<code>HTTP</code>。</li>
<li>费用：<code>HTTPS</code>需要使用<code>SSL</code>证书，功能越强大的证书其费用越高；<code>HTTP</code>不需要。</li>
</ul>
<h4 id="4、http返回状态码"><a href="#4、http返回状态码" class="headerlink" title="4、http返回状态码"></a>4、http返回状态码</h4><p>状态码第一位数字决定了不同的响应状态：<br> <code>1xx</code>表示请求已被接受，需要继续处理；<br> <code>2xx</code>表示请求成功；<br> <code>3xx</code>表示重定向；<br> <code>4xx</code>表示客户端错误；<br> <code>5xx</code>表示服务端错误。</p>
<p>常见的状态码：</p>
<ul>
<li><code>101</code>：服务器根据客户端的请求切换协议，主要用于<code>websocket</code>或<code>http2</code>升级</li>
<li><code>200</code>：请求已成功，请求所希望的数据将随响应一起返回。</li>
<li><code>201</code>：请求成功并且服务器创建了新的资源。</li>
<li><code>202</code>：服务器已接受响应请求，但尚未处理。</li>
<li><code>301</code>：请求的网页已永久移动至新的位置。</li>
<li><code>302</code>：临时重定向/临时转移。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</li>
<li><code>304</code>：本次获取到的内容是读取缓存中的数据，会每次去服务器校验。</li>
<li><code>401</code>：请求需要进行身份验证，尚未认证，没有登录网站。</li>
<li><code>403</code>：禁止访问，服务器拒绝请求。</li>
<li><code>404</code>：服务器没有找到相应资源。</li>
<li><code>500</code>：服务器遇到错误，无法完成对请求的处理。</li>
<li><code>503</code>：服务器无法使用。</li>
</ul>
<h4 id="5、http1-0和1-1的区别"><a href="#5、http1-0和1-1的区别" class="headerlink" title="5、http1.0和1.1的区别"></a>5、http1.0和1.1的区别</h4><p>连接：<code>HTTP 1.0</code>默认使用非持久连接，<code>HTTP 1.1</code>则默认使用持久连接。<code>HTTP 1.1</code>通过使用持久连接来使多个HTTP请求复用同一个<code>TCP</code>连接，避免了<code>HTTP 1.0</code>中使用非持久连接造成的每次请求都需要建立连接的时延。</p>
<p>缓存：<code>HTTP 1.0</code>主要使用<code>header</code>中的<code>If-Modified-Since</code>，<code>Expires</code> 来做为缓存判断的标准；<code>HTTP 1.1</code>则引入了更多的缓存控制策略，例如：<code>Etag</code>、<code>If-Unmodified-Since</code>、<code>If-Match</code>、<code>If-None-Match</code>等更多可供选择的缓存头来控制缓存策略。</p>
<p>资源请求：<code>HTTP 1.0</code>中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能；<code>HTTP 1.1</code>则在请求头引入了<code>range</code> 头域，它允许只请求资源的某个部分，即返回码是 <code>206（Partial Content）</code>，这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p>host：<code>HTTP 1.1</code>引入了<code>host</code>，用来指定服务器的域名。</p>
<p>方法：<code>HTTP 1.1</code>相较于<code>HTTP 1.0</code>新增了许多方法，如：<code>put</code>、<code>delete</code>、<code>options</code>等。</p>
<h4 id="6、get和post区别"><a href="#6、get和post区别" class="headerlink" title="6、get和post区别"></a>6、get和post区别</h4><ol>
<li>参数位置：<code>GET</code>请求的参数是放在 url 中，<code>POST</code>请求放在请求体 body 中。</li>
<li>参数长度：<code>GET</code>请求在 url 中传递的参数有长度限制（主要是因为浏览器对 url 长度有限制），<code>POST</code>则没有。</li>
<li>参数的数据类型：<code>GET</code>只接受ASCII字符，而<code>POST</code>没有限制。</li>
<li>安全：<code>POST</code>比<code>GET</code>安全，因为数据在地址栏上不可见。但是从传输角度考虑，二者都是不安全的，因为<code>HTTP</code>是明文传输。</li>
<li>幂等性：<code>GET</code>是一个幂等的请求；<code>POST</code>不是。（幂等，指同⼀个请求⽅法执⾏多次和仅执⾏⼀次的效果完全相同）</li>
<li>缓存：<code>GET</code>请求会被浏览器主动cache，而<code>POST</code>不会，除非手动设置。</li>
</ol>
<h4 id="7、如何解决跨域问题？"><a href="#7、如何解决跨域问题？" class="headerlink" title="7、如何解决跨域问题？"></a>7、如何解决跨域问题？</h4><p>跨域问题起源于浏览器的同源策略，同源即协议 端口 域名三者一样 才算同源 。同源策略是为了保护用户的上网安全。</p>
<p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。</p>
<p><strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。</p>
<p><strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p>
<p><code>JSONP</code>：Jsonp(JSON with Padding) 是 json 的一种”使用模式”，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p>
<p><code>CORS</code>：CORS(Cross-origin resource sharing)跨域资源共享，服务器设置对 CORS 的支持。其原理是，服务器设置 Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求。实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<p><code>proxy代理</code>：最常用多方式。通俗点说就是客户端浏览器发起一个请求会存在跨域问题，但是服务端向另一个服务端发起请求并无跨域，因为跨域问题归根结底源于同源策略，而同源策略只存在于浏览器。那么我们是不是可以通过 Nginx 配置一个代理服务器，反向代理访问跨域的接口，并且我们还可以修改 Cookie 中 domain 信息，方便当前域 Cookie 写入。</p>
<h4 id="8、正向代理和反向代理"><a href="#8、正向代理和反向代理" class="headerlink" title="8、正向代理和反向代理"></a>8、正向代理和反向代理</h4><p>正向代理隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求。</p>
<p>反向代理隐藏了真实的服务端，当发送一个请求时，其背后可能有很多台服务器为我们服务，但具体是哪一台，我们不知道，也不需要知道，我们只需要知道反向代理服务器是谁就好了，反向代理服务器会帮我们把请求转发到真实的服务器那里去。反向代理器一般用来实现负载平衡。</p>
<h4 id="9、DNS-协议"><a href="#9、DNS-协议" class="headerlink" title="9、DNS 协议"></a>9、DNS 协议</h4><ol>
<li>概念：<br><code>DNS（Domain Namse System）</code>，域名系统，是进行域名和其相应IP地址进行转换的服务器。可以将<code>DNS</code>理解为一个翻译官，负责把域名转换为相应的IP地址。<code>DNS</code>协议运行在UDP协议之上，使用<code>53</code>号端口。</li>
<li><code>DNS</code>查询方式分为<code>递归查询</code>和<code>迭代查询</code>两种。所谓<code>递归查询</code>，就是A向B请求，如果B不知道所请求的内容，则B将继续向上请求，直到获得所需的内容，然后将内容返回给A。<code>迭代查询</code>，就是A向B请求，如果B不知道，则B会告诉A如何获得该内容，让A继续去请求。</li>
</ol>
<h4 id="10、即时通讯的链接方式"><a href="#10、即时通讯的链接方式" class="headerlink" title="10、即时通讯的链接方式"></a>10、即时通讯的链接方式</h4><p>主要有四种方式，它们分别是<code>轮询</code>、<code>长轮询(comet)</code>、<code>长连接(SSE)</code>、<code>WebSocket</code>。它们大体可以分为两类，一种是在HTTP基础上实现的，包括短轮询、comet和SSE；另一种不是在HTTP基础上实现是，即WebSocket。</p>
<ol>
<li><code>轮询</code><br> 短轮询的基本思路就是浏览器每隔一段时间向浏览器发送http请求，服务器在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。<br> 优点：比较简单，易于理解，实现起来没有什么技术难点。<br> 缺点：由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。</li>
<li><code>长轮询</code><br> 当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应；如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。<br> 优点：长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。<br> 缺点：连接挂起也会导致资源的浪费。</li>
<li><code>长连接</code><br> <code>SSE</code>是HTML 5新增的功能，全称为<code>Server-Sent Events</code>。它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询、短轮询不同，虽然都是基于http协议的，但是轮询需要客户端先发送请求。而SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。 优点：不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能；实现非常简单，并且不需要依赖其他插件。</li>
<li><code>WebSocket</code><br> WebSocket是HTML 5定义的一个新协议，与传统的http协议不同，该协议可以实现服务器与客户端之间全双工通信。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要http。连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。<br> 优点：实现了双向通信。<br> 缺点：服务器端的逻辑非常复杂。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://corookie.github.io">Corookie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://corookie.github.io/2023/02/07/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/">https://corookie.github.io/2023/02/07/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://corookie.github.io" target="_blank">Corookie's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/15/50days%2050project/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">50days 50project</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/21/ajax/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ajax</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/icon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Corookie</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/corookie"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">热烈、坦诚、自由</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-number">1.1.</span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81html%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">1.1.1.</span> <span class="toc-text">1、html语义化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81script%E4%B8%ADdefer%E5%92%8Casync%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.2.</span> <span class="toc-text">2、script中defer和async的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81DOCTYPE"><span class="toc-number">1.1.3.</span> <span class="toc-text">3、DOCTYPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81SGML%E3%80%81HTML%E3%80%81XML-%E5%92%8C-XHTML%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.4.</span> <span class="toc-text">4、SGML、HTML、XML 和 XHTML的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81HTML5"><span class="toc-number">1.1.5.</span> <span class="toc-text">5、HTML5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.6.</span> <span class="toc-text">6、浏览器内核的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%A1%A3%E7%9A%84%E9%A2%84%E8%A7%A3%E6%9E%90%EF%BC%9F"><span class="toc-number">1.1.7.</span> <span class="toc-text">7、什么是文档的预解析？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81sessionStorage%EF%BC%8ClocalStorage-%E5%92%8C-cookie-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.8.</span> <span class="toc-text">8、sessionStorage，localStorage 和 cookie 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81iframe-%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.1.9.</span> <span class="toc-text">9、iframe 有哪些优缺点？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-number">1.2.</span> <span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E8%AF%B4%E4%B8%80%E8%AF%B4CSS%E7%9A%84%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">1、说一说CSS的盒子模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81css%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、css选择器优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%85%83%E7%B4%A0%E9%9A%90%E8%97%8F%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.2.3.</span> <span class="toc-text">3、元素隐藏方法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81px%E5%92%8Crem%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.4.</span> <span class="toc-text">4、px和rem的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%92%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.5.</span> <span class="toc-text">5、重绘重排有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E8%AE%A9%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.2.6.</span> <span class="toc-text">6、让一个元素水平垂直居中的方法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81CSS%E5%B1%9E%E6%80%A7%E9%82%A3%E4%BA%9B%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E9%82%A3%E4%BA%9B%E4%B8%8D%E8%83%BD%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.7.</span> <span class="toc-text">7、CSS属性那些可以继承那些不能继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E6%9C%89%E6%B2%A1%E6%9C%89%E7%94%A8%E8%BF%87%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">1.2.8.</span> <span class="toc-text">8、有没有用过预处理器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVASCRIPT"><span class="toc-number">1.3.</span> <span class="toc-text">JAVASCRIPT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81JS%E7%94%B1%E9%82%A3%E4%B8%89%E9%83%A8%E5%88%86%E7%BB%84%E6%88%90"><span class="toc-number">1.3.1.</span> <span class="toc-text">1、JS由那三部分组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81JS%E6%9C%89%E9%82%A3%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">2、JS有那些内置对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%93%8D%E4%BD%9C%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E9%82%A3%E4%BA%9B"><span class="toc-number">1.3.3.</span> <span class="toc-text">3、操作数组的方法有那些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81-JS%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">4、 JS对数据的检测方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E9%97%AD%E5%8C%85%EF%BC%8C%E9%97%AD%E5%8C%85%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%E3%80%82"><span class="toc-number">1.3.5.</span> <span class="toc-text">5、说一下闭包，闭包有什么特点。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.6.</span> <span class="toc-text">7、事件委托是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.7.</span> <span class="toc-text">8、基本数据类型和引用数据类型的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E8%AF%B4%E4%B8%80%E4%B8%8B%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.3.8.</span> <span class="toc-text">9、说一下原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.9.</span> <span class="toc-text">10、new操作符具体做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-number">1.3.10.</span> <span class="toc-text">11、类型判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81bind-call-apply%E5%8C%BA%E5%88%AB"><span class="toc-number">1.3.11.</span> <span class="toc-text">12、bind, call, apply区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VUE"><span class="toc-number">1.4.</span> <span class="toc-text">VUE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81mvvm%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">1、mvvm模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81vue%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">2、vue数据双向绑定原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">3、vue生命周期钩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81v-if-%E5%92%8C-v-show"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">4、v-if 和 v-show</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81async-%EF%BC%88a-sin-k%EF%BC%89await-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%AE%83%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.4.0.5.</span> <span class="toc-text">5、async （a sin k）await 是什么？它有哪些作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81-%E8%B0%88%E8%B0%88%E9%97%AD%E5%8C%85"><span class="toc-number">1.4.0.6.</span> <span class="toc-text">6、 谈谈闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81ES6%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.4.0.7.</span> <span class="toc-text">7、ES6新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81key%E5%92%8Cindex"><span class="toc-number">1.4.0.8.</span> <span class="toc-text">8、key和index</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84-data-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AE%9A%E4%B9%89%E6%88%90%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">1.4.0.9.</span> <span class="toc-text">9、组件中的 data 为什么要定义成一个函数而不是一个对象？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81vue-%E4%B8%AD-computed-%E5%92%8C-watch-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.0.10.</span> <span class="toc-text">10、vue 中 computed 和 watch 的区别是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11%E3%80%81"><span class="toc-number">1.4.0.11.</span> <span class="toc-text">11、</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.5.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.0.1.</span> <span class="toc-text">1、输入url到页面渲染发生了什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81http%E8%AF%B7%E6%B1%82"><span class="toc-number">1.5.0.2.</span> <span class="toc-text">2、http请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81https%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.0.3.</span> <span class="toc-text">3、https和http的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81http%E8%BF%94%E5%9B%9E%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.5.0.4.</span> <span class="toc-text">4、http返回状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%E3%80%81http1-0%E5%92%8C1-1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.0.5.</span> <span class="toc-text">5、http1.0和1.1的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%E3%80%81get%E5%92%8Cpost%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.0.6.</span> <span class="toc-text">6、get和post区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.5.0.7.</span> <span class="toc-text">7、如何解决跨域问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8%E3%80%81%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="toc-number">1.5.0.8.</span> <span class="toc-text">8、正向代理和反向代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9%E3%80%81DNS-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.0.9.</span> <span class="toc-text">9、DNS 协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10%E3%80%81%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E7%9A%84%E9%93%BE%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.0.10.</span> <span class="toc-text">10、即时通讯的链接方式</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/19/typeScript/" title="typeScript"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="typeScript"/></a><div class="content"><a class="title" href="/2023/02/19/typeScript/" title="typeScript">typeScript</a><time datetime="2023-02-19T07:41:57.000Z" title="发表于 2023-02-19 15:41:57">2023-02-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/15/50days%2050project/" title="50days 50project"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="50days 50project"/></a><div class="content"><a class="title" href="/2023/02/15/50days%2050project/" title="50days 50project">50days 50project</a><time datetime="2023-02-15T07:23:28.000Z" title="发表于 2023-02-15 15:23:28">2023-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/07/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="前端常见问题"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端常见问题"/></a><div class="content"><a class="title" href="/2023/02/07/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" title="前端常见问题">前端常见问题</a><time datetime="2023-02-07T07:45:23.000Z" title="发表于 2023-02-07 15:45:23">2023-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/21/ajax/" title="ajax"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ajax"/></a><div class="content"><a class="title" href="/2022/12/21/ajax/" title="ajax">ajax</a><time datetime="2022-12-21T07:11:43.000Z" title="发表于 2022-12-21 15:11:43">2022-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/21/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" title="前端模块化"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端模块化"/></a><div class="content"><a class="title" href="/2022/11/21/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" title="前端模块化">前端模块化</a><time datetime="2022-11-21T06:50:20.000Z" title="发表于 2022-11-21 14:50:20">2022-11-21</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Corookie</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>